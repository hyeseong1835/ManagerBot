<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Collection</name>
    </assembly>
    <members>
        <member name="P:HS.Common.Collection.Unmanaged.IPtrEnumerator`1.CurrentPtr">
            <summary>
            현재 열거자가 가리키는 값의 포인터입니다.
            </summary>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.IUnmanagedLinkedList`1">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트를 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="TNode"></typeparam>
        </member>
        <member name="P:HS.Common.Collection.Unmanaged.IUnmanagedLinkedListNode`1.NextNodePtr">
            <summary>
            다음 노드의 포인터입니다.
            </summary>
        </member>
        <member name="M:HS.Common.Collection.Unmanaged.IUnmanagedLinkedListNodeEnumerator`1.Init(`0*)">
            <summary>
            HeadNodePtr를 재설정하고 Reset()을 호출합니다.
            </summary>
            <param name="headNodePtr"></param>
        </member>
        <member name="M:HS.Common.Collection.Unmanaged.IUnmanagedLinkedListValueEnumerator`2.Init(`1*)">
            <summary>
            HeadNode를 재설정하고 Reset()을 호출합니다.
            </summary>
            <param name="headNodePtr"></param>
        </member>
        <member name="P:HS.Common.Collection.Unmanaged.IReadOnlyUnmanagedValueLinkedListNode`1.Value">
            <summary>
            노드의 값입니다.
            </summary>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.IUnmanagedValueLinkedList`2">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트를 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TNode"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.UnmanagedLinkedList`1">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트를 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="TNode"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.UnmanagedPtrLinkedList`1">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트를 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.UnmanagedPtrLinkedList`2">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트를 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TNode"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.UnmanagedValueLinkedList`1">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트를 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.UnmanagedValueLinkedList`2">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트를 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TNode"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.UnmanagedPtrStack`1">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트 기반 스택을 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.Unmanaged.UnmanagedStack`1">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트 기반 스택을 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:HS.Common.Collection.SortedArrayDictionary`2">
            <summary>
            버퍼를 사용하여 정렬된 키-값 쌍을 저장하는 사전입니다. <br/>
            이진 탐색을 이용하여 탐색합니다.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:HS.Common.Collection.SortedArrayDictionary`2.Remove(`0)">
            <summary>
            지정된 키의 아이템을 제거하고 그 뒤의 아이템을 당깁니다. <br/>
            마지막 아이템은 복제됩니다. 후에 참조가 제거되지 않을 수 있으므로 메모리 누수 위험이 있는 경우 RemoveCompletely(TKey)를 사용하세요
            </summary>
            <param name="key"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="M:HS.Common.Collection.SortedArrayDictionary`2.RemoveCompletely(`0)">
            <summary>
            지정된 키의 아이템을 제거하고 그 뒤의 아이템을 당깁니다. <br/>
            마지막 아이템은 초기화됩니다. 메모리 누수 위험이 없는 경우 Remove(TKey)가 성능상 더 좋습니다.
            </summary>
            <param name="key"></param>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException"></exception>
        </member>
        <member name="M:HS.Common.Collection.SortedArrayDictionary`2.Clear">
            <summary>
            개수를 0으로 설정합니다. <br/>
            참조가 제거되지 않으므로 메모리 누수 위험이 있습니다. 내부 배열을 모두 초기화하려면 ClearCompletely()를 사용하세요.
            </summary>
        </member>
        <member name="M:HS.Common.Collection.SortedArrayDictionary`2.ClearCompletely">
            <summary>
            모든 아이템을 제거하고 내부 배열을 초기화합니다. <br/>
            Clear()와 달리 메모리 누수 위험이 없습니다. 값 형식이거나 메모리 누수 위험이 없다면 Clear()를 사용하는 것이 성능상 좋습니다.
            </summary>
        </member>
        <member name="M:HS.Common.Collection.SortedArrayDictionary`2.Push(System.Int32)">
            <summary>
            지정된 인덱스의 아이템부터 뒤로 밀어냅니다. <br/>
            index의 아이템은 다음 인덱스로 복제됩니다.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:HS.Common.Collection.SortedArrayDictionary`2.Pull(System.Int32)">
            <summary>
            index 다음 아이템부터 index로 당겨옵니다. <br/>
            참조가 제거되지 않으므로 메모리 누수 위험이 있습니다. 마지막 원소를 초기화하려면 CompletelyPull()를 사용하세요.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:HS.Common.Collection.SortedArrayDictionary`2.PullCompletely(System.Int32)">
            <summary>
            index 다음 아이템부터 index로 당겨옵니다. <br/>
            Pull()와 달리 메모리 누수 위험이 없습니다. 값 형식이거나 메모리 누수 위험이 없다면 Pull()를 사용하는 것이 성능상 좋습니다.
            </summary>
            <param name="index"></param>
        </member>
        <member name="T:HS.Common.Collection.UnmanagedSpanStack`1">
            <summary>
            관리되지 않는 메모리에서 싱글 링크드 리스트 기반 스택을 구현합니다. <br/>
            <br/>
            더 이상 사용하지 않을 때 Dispose()를 호출해야합니다.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
    </members>
</doc>
